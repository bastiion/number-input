<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../property-mixins/range-mixin.html">
<link rel="import" href="../property-mixins/intl-number-format-mixin.html">
<link rel="import" href="../input-picker-pattern/form-element-mixin.html">

<script>
  /**
   * mixin to create a number-input
   *
   * @appliesMixin IntlNumberFormatMixin
   * @appliesMixin RangeMixin
   * @appliesMixin FormElementMixin
   *
   * @mixinFunction
   * @polymer
   */
  const NumberInputMixin = superClass => { // eslint-disable-line no-unused-vars

    return class extends RangeMixin(FormElementMixin(IntlNumberFormatMixin(superClass))) {  // eslint-disable-line no-undef

      static get template() {
        return `
          ${this.styleTemplate}
          ${this.contentTemplate}
        `;
      }

      static get styleTemplate() {
        return `
          <style>
            :host {
              display: inline-flex;
              box-sizing: content-box;
              padding: 0 !important;
            }
            :host(:focus) {
              outline: none;
            }
            :host([invalid]) #input,
            #input:invalid {
              @apply --input-invalid;
              @apply --number-input-invalid;
            }
            #size,
            #input {
              font-family: inherit;
              font-size: inherit;
              font-weight: inherit;
              border: none;
              outline: none;
              border-color: transparent;
              line-height: normal;
              color: var(--number-input-color, var(--input-color, inherit));
              background: var(--number-input-background, var(--input-background, transparent));
              text-align: var(--number-input-allign, center);
              @apply --input-style;
              @apply --number-input;
              overflow: visible;
              -webkit-background-clip: padding-box;
              background-clip: padding-box;
              box-sizing: border-box;
            }
            #size {
              position: fixed;
              top: 0; left: 0;
              visibility: hidden !important;
              opacity: 0 !important;
              pointer-events: none !important;
            }
            #input::-webkit-input-placeholder,
            #input::placeholder {
              @apply --input-placeholder;
              @apply --number-input-placeholder;
            }
            #input:hover,
            #input:focus {
              outline: none;
              color: var(--number-input-focus-color, var(--input-focus-color, inherit));
              background: var(--number-input-focus-background, var(--input-focus-background, rgba(0,0,0,0.1)));
              @apply --input-focus;
              @apply --number-input-focus;
            }
            :host([disabled]) {
              color: var(--number-input-disabled-color, var(--input-disabled-color, inherit));
              background: var(--number-input-disabled-background, var(--input-disabled-background, inherit));
              @apply --input-disabled;
            }
            input::-moz-focus-inner {
              border-style: none;
              padding: 0;
            }
            input::-moz-focusring {
              border-width: 0;
              color: transparent;
              text-shadow: 0 0 0 var(--number-input-focus-color, var(--input-focus-color, #000));
            }
            input::-moz-selection {
              color: var(--number-input-color, var(--input-color, inherit));
              background: var(--number-input-background, var(--input-background, transparent));
            }
            input:focus::-moz-selection {
              color: var(--input-selection-color, inherit);
              background: var(--input-selection-background, rgba(255,255,255,0.5));
            }
            input::selection {
              color: var(--number-input-color, var(--input-color, inherit));
              background: var(--number-input-background, var(--input-background, transparent));
            }
            input:focus::selection {
              color: var(--input-selection-color, inherit);
              background: var(--input-selection-background, rgba(255,255,255,0.5));
            }
          </style>
        `;
      }

      /**
       * An input of type 'tel' is used to use on mobile devices an numeric keyboard.
       * To compute the correct width of the input a div is used that uses the same style (only that it is not visible and not bound to the context) to compute the style.
       */
      static get contentTemplate() {
        return `
          <input id="input"
            type="tel"
            placeholder="[[placeholder]]"
            required="[[required]]"
            disabled="[[disabled]]"
            spellcheck="false">
          <div id="size"><div>
        `;
      }

      static get properties() {
        return {
          /**
           * length to pad the string (with `0`) according to the total amount of numbers
           * @type {number}
           */
          padLength: {
            type: Number
          },

          /**
           * placeholder string
           * @type {string}
           */
          placeholder: {
            type: String
          },

          /**
           * if set `true`, the attributes `min`, `max`, `start-at` and `default` won't be used to compute a mininmal width. `minlenght` and `placeholder` will still be used.
           */
          noAutoWidth: {
            type: String
          },

          /**
           * always put the sign at the beginning
           */
          alwaysSign: {
            type: Boolean,
            observer: '_updateValue'
          },

          /**
           * enables auto padding
           * @type {boolean}
           */
          autoPadding: {
            type: Boolean
          },

          /**
           * string value of the input
           * @type {string}
           */
          input: {
            type: String,
            notify: true,
            observer: '_inputChanged'
          },

          /**
           * start where to increment the value
           */
          startAt: {
            type: Number
          },

          /**
           * minimum character width of the input
           */
          minlength: {
            type: Number
          },

          /**
           * minimum digits right to the decimal separator
           */
          minimumFractionDigits: {
            type: Number,
            computed: '_computeMinimumFractionDigits(_step, min, max, numberStyle)'
          },

          /**
           * maximum digits right to the decimal separator
           */
          maximumFractionDigits: {
            type: Number,
            computed: '_computeMaximumFractionDigits(minimumFractionDigits, noClamp)'
          },

          /**
           * minimum digits left to the decimal separator to pad
           */
          minimumIntegerDigits: {
            type: Number,
            computed: '_computeMinimumIntegerDigits(autoPadding, padLength, default, startAt, min, max, _step, numberStyle)'
          }
        }
      }

      static get observers() {
        return [
          '_computeMinWidth(noAutoWidth, formatNumber, placeholder, minlength, default, startAt, min, max, minimumIntegerDigits, minimumFractionDigits)'
        ]
      }

      connectedCallback() {
        super.connectedCallback();
        this.focus = this.focus.bind(this);
        this._stopIncrem = this._stopIncrem.bind(this);
        this._updateValue = this._updateValue.bind(this);
        this._checkInput = this._checkInput.bind(this);
        this._checkKeycode = this._checkKeycode.bind(this);
        this._addEventListeners();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._removeEventListeners();
      }

      _addEventListeners() {
        this.addEventListener('focus', this.focus, false);
        this.addEventListener('contextmenu', this._stopIncrem, false);
        this.$.input.addEventListener('focus', this._updateValue, false);
        this.$.input.addEventListener('blur', this._updateValue, false);
        this.$.input.addEventListener('keydown', this._checkKeycode, false);
        this.$.input.addEventListener('keyup', this._stopIncrem, false);
      }

      _removeEventListeners() {
        this.removeEventListener('focus', this.focus, false);
        this.removeEventListener('contextmenu', this._stopIncrem, false);
        this.$.input.removeEventListener('focus', this._updateValue, false);
        this.$.input.removeEventListener('blur', this._updateValue, false);
        this.$.input.removeEventListener('keydown', this._checkKeycode, false);
        this.$.input.removeEventListener('keyup', this._stopIncrem, false);
      }

      /**
       * focus the input
       */
      focus() {
        this.$.input.focus();
        if (this.$.input.scrollIntoViewIfNeeded) {
          this.$.input.scrollIntoViewIfNeeded();
        }
      }

      /**
       * focus the input
       */
      blur(e) {
        this.$.input.blur();
        e && e.stopPropagation && e.stopPropagation();
      }

      _checkKeycode(e) {
        if (!e.target) {
          if (e && e.preventDefault) e.preventDefault();
          return;
        }
        // up or down key press
        const inc = (e.keyCode === 38) ? this._step : (e.keyCode === 40 ? -this._step : 0);
        if (inc !== 0) {
          this._startIncrem(inc);
          e.stopPropagation();
          return;
        }

        // enter & space
        if (e.keyCode === 13 || e.keyCode === 32) {
          this._checkInput();
          return;
        }

        // esc
        if (e.keyCode === 27) {
          this._updateValue();
          e.stopPropagation();
          this.blur();
          return;
        }
      }

      _startIncrem(step) {
        this._stopIncrem();
        this._increm(step);
        this._activeIncremJob = setInterval(() => {
          this._increm(step);
        }, 150);
      }

      _stopIncrem() {
        if (this._activeIncremJob) {
          clearInterval(this._activeIncremJob);
        }
      }

      _increm(step) {
        let value = this._safeAdd(this.parseNumber(this.$.input.value), step);
        if (isNaN(value)) {
          if (!isNaN(this.startAt)) {
            this.value = this.startAt;
          } else if (!isNaN(this.default)) {
            this.value = this.default;
          } else {
            this.value = this.min < 0 ? 0 : this.min || 0;
          }
        } else if (this.noClamp) {
          // still clamp to step, when incrementing
          this.value = this._checkStep(this._checkValue(value, this.value), step);
        } else {
          this.value = this._checkValue(value, this.value);
        }
      }

      _computeInvalid(required, value) {
        this.invalid = required && isNaN(value);
      }

      _inputChanged(input) {
        if (!input) {
          if (!isNaN(this.default)) {
            this.input = '' + this.default;
          } else {
            this.$.input.value = '';
            this._debouncedComputeWidth(input);
          }
          return;
        }
        const value = this._checkValue(this.parseNumber(input), this.value);
        input = this.formatNumber(value);

        if (this.input !== input) {
          this.input = input;
          return;
        }

        this.$.input.value = input;
        this.value = value;

        this._debouncedComputeWidth(input);
      }

      _valueChanged(value, oldValue) {
        if (value === undefined) {
          if (!isNaN(this.default)) {
            this.value = this.default;
          } else {
            this.input = undefined;
            this._debouncedComputeWidth();
          }
          return;
        }

        if (isNaN(oldValue)) {
          value = this._checkValue(value);
        } else {
          value = this._checkValue(value, oldValue);
        }

        if (this.value !== value) {
          this.value = value;
          return;
        }
        this.input = this.$.input.value = this.formatNumber(value);
      }

      _checkInput(e) {
        this._inputChanged(this.$.input.value);
        e && e.stopPropagation && e.stopPropagation();
      }

      _updateValue(e) {
        this._valueChanged(this.value);
        e && e.stopPropagation && e.stopPropagation();
      }

      _debouncedComputeWidth(input) {
        if (this._activeResizeJob) {
          window.cancelAnimationFrame(this._activeResizeJob);
        }
        this.$.size.innerHTML = input || this._minWidthString || '';
        this._activeResizeJob = window.requestAnimationFrame(this._computeWidth.bind(this));
      }

      _computeWidth() {
        this.$.input.style.width = `${this.$.size.getBoundingClientRect().width}px`;
      }

      _computeMinWidth(noAutoWidth, formatNumber, placeholder, minlength, def, startAt, min, max, minimumIntegerDigits, minimumFractionDigits) {
        def = formatNumber(def || 0);
        startAt = formatNumber(startAt || 0);
        min = formatNumber(min || 0);
        max = formatNumber(max || 0);
        minlength = formatNumber(Math.pow(10, (minlength || 1) - 1));
        let gen = (!this.alwaysSign && (min < 0 || max < 0) ? '-' : '') + formatNumber(Math.pow(10, (minimumIntegerDigits || 1) - 1) + Math.pow(10, -(minimumFractionDigits || 0)));
        this.$.size.innerHTML = this._minWidthString = (noAutoWidth ? [minlength] : [minlength, gen, def, startAt, min, max]).reduce( (acc, curr) => {
          return curr.length > acc.length ? curr : acc;
        }, placeholder || '');
        setTimeout(() => {
          const minWidth = this.$.size.getBoundingClientRect().width;
          this.$.input.style.minWidth = `${minWidth}px`;
          this._updateValue();
        }, 0)
      }

      _computeMinimumIntegerDigits(autoPadding, padLength, def, startAt, min, max, step, numberStyle) {
        if (numberStyle === 'percent') {
          min = Math.round(min * 100);
          max = Math.round(max * 100);
          def = Math.round(def * 100);
          step = Math.round(step * 100);
          startAt = Math.round(startAt * 100);
        } else {
          min = Math.round(min);
          max = Math.round(max);
          def = Math.round(def);
          step = Math.round(step);
          startAt = Math.round(startAt);
        }
        min = '' + (Math.abs(min) || 0);
        max = '' + (Math.abs(max) || 0);
        def = '' + (Math.abs(def) || 0);
        step = '' + (Math.abs(step) || 0);
        startAt = '' + (Math.abs(startAt) || 0);

        if (autoPadding) {
          return Math.max((padLength || 1), startAt.length, step.length, def.length, min.length, max.length);
        }
        return padLength || 1;
      }

      _computeMinimumFractionDigits(step, min, max, numberStyle) {
        if (numberStyle === 'percent') {
          min = this._safeMult(min || 0, 100);
          max = this._safeMult(max || 0, 100);
          step = this._safeMult(step || 0.01, 100);
        }

        min = '' + (Math.abs(min) || '');
        max = '' + (Math.abs(max) || '');
        step = '' + step;

        return ['0', step, min, max].reduce( (acc, curr) => {
          const pos = curr.indexOf('.');
          return Math.max((pos < 0) ? 0 : (curr.length - 1 - pos), acc);
        });
      }

      _computeMaximumFractionDigits(minimumFractionDigits, noClamp) {
        if (noClamp) {
          return 20;
        }
        return minimumFractionDigits;
      }
    }
  }

</script>

<dom-module id="number-input">
  <script>
    /**
     *  `number-input` is an element that can:
     * * prevent non numeric input
     * * guarantee **live**-data to be valid
     * * pad a value with `0` (to a specific length)
     * * size the input (according to it's length)
     * * overflow to minimum or underflow to maximum
     * * saturate to minimum or to maximum
     * * display a specified unit and size the input
     * * specify the decimal separator (the value will still be a Number object)
     * * use percent-format
     *
     * Example:
     * ```html
     * <number-input step="2" min="-20" max="140" pad-length="2"></number-input>
     * ```
     *
     * It sizes automatically. Use `key-up` and `key-down` to increment the value. If `step` is given, the value is a **multiple** of `step`.
     *
     * ### Styling
     * Custom property                   | Description                                  | Default
     * ----------------------------------|----------------------------------------------|--------------------
     * `--number-input`                  | style of the input                           | {}
     * `--number-input-focus`            | style of the focussed and hovered input      | {}
     * `--number-input-placeholder`      | style of the placeholder                     | {}
     * `--number-input-color`            | color of the input                           | inherit
     * `--number-input-background`       | background of the input                      | inherit
     * `--number-input-focus-color`      | color of the focussed and hovered input      | inherit
     * `--number-input-focus-background` | background of the focussed and hovered input | rgba(0,0,0,0.1)
     * `--number-input-disabled-color`   | color of the disabled input                  | inherit
     * `--input-selection-color`         | color of the selected text                   | inherit
     * `--input-selection-background`    | background of the selected text              | rgba(255,255,255,0.5
     *
     * ```css
     * :host {
     *   --number-input-disabled-color: grey;
     *   --number-input-focus-background: rgba(0,0,0,0.25);
     *   --number-input-focus: {
     *     font-weight: bold;
     *   };
     *   --number-input-placeholder: {
     *     color: pink;
     *   };
     * }
     * ```
     * @polymer
     * @customElement
     *
     * @appliesMixin NumberInputMixin
     *
     * @demo demo/index.html
     * @demo demo/form.html Form Demo
     **/
    class NumberInput extends NumberInputMixin(Polymer.Element) {  // eslint-disable-line no-undef

      static get is() {
        return 'number-input';
      }
    }
    window.customElements.define(NumberInput.is, NumberInput);
  </script>
</dom-module>
